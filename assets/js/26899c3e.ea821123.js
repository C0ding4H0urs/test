"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4289],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return u}});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=c(t),u=i,g=p["".concat(l,".").concat(u)]||p[u]||m[u]||a;return t?r.createElement(g,s(s({ref:n},d),{},{components:t})):r.createElement(g,s({ref:n},d))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,s=new Array(a);s[0]=p;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var c=2;c<a;c++)s[c]=t[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},9102:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return d},default:function(){return p}});var r=t(7462),i=t(3366),a=(t(7294),t(3905)),s=["components"],o={title:"Custom Command to File"},l=void 0,c={unversionedId:"utilities/cc2file",id:"utilities/cc2file",isDocsHomePage:!1,title:"Custom Command to File",description:'This command sends your custom command code(s) as a text file, rather than "plain" Discord messages, preserving tabs, markdown, etc.',source:"@site/docs/utilities/cc2file.md",sourceDirName:"utilities",slug:"/utilities/cc2file",permalink:"/utilities/cc2file",editUrl:"https://github.com/yagpdb-cc/yagpdb-cc/edit/master/website/docs/utilities/cc2file.md",tags:[],version:"current",frontMatter:{title:"Custom Command to File"},sidebar:"sidebar",previous:{title:"Bookmark Message",permalink:"/utilities/bookmark"},next:{title:"Preview Color",permalink:"/utilities/color-preview"}},d=[{value:"Trigger",id:"trigger",children:[]},{value:"Usage",id:"usage",children:[{value:"Example",id:"example",children:[]}]},{value:"Configuration",id:"configuration",children:[]},{value:"Code",id:"code",children:[]},{value:"Author",id:"author",children:[]}],m={toc:d};function p(e){var n=e.components,t=(0,i.Z)(e,s);return(0,a.kt)("wrapper",(0,r.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,'This command sends your custom command code(s) as a text file, rather than "plain" Discord messages, preserving tabs, markdown, etc.'),(0,a.kt)("p",null,"You can specify more than one ID or trigger, and the bot will generate one file per input parameter. If none are provided, output will be the entire CC list."),(0,a.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"The built-in ",(0,a.kt)("inlineCode",{parentName:"p"},"cc")," command received a recent update that allows it to show code in file format as well: see the ",(0,a.kt)("inlineCode",{parentName:"p"},"-file")," switch. However, it does not support showing multiple custom commands, which is where this command comes in handy."))),(0,a.kt)("h2",{id:"trigger"},"Trigger"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Type:")," ",(0,a.kt)("inlineCode",{parentName:"p"},"Command"),(0,a.kt)("br",null),"\n",(0,a.kt)("strong",{parentName:"p"},"Trigger:")," ",(0,a.kt)("inlineCode",{parentName:"p"},"cc2file")),(0,a.kt)("h2",{id:"usage"},"Usage"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"-cc2file <id_or_trigger...>")," - Sends the custom command codes of all the custom commands provided.")),(0,a.kt)("h3",{id:"example"},"Example"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'-cc2file 10 "te st" 23\n')),(0,a.kt)("p",null,"Sends the code for the custom command with the ID 10, the custom command with the trigger ",(0,a.kt)("inlineCode",{parentName:"p"},"te st"),", and the custom command with the ID 23."),(0,a.kt)("h2",{id:"configuration"},"Configuration"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"$limitTo5CCs"),(0,a.kt)("br",null),"\nWhether or not to limit the output to five custom commands, to prevent spam.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"$CCInfo_MessageContent"),(0,a.kt)("br",null),"\nWhether or not the info for each custom command should be included in the message content.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"$CCInfo_Attachment"),(0,a.kt)("br",null),"\nWhether or not the info for each custom command should be included in the attached file.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"$blacklisted_CCIDs"),(0,a.kt)("br",null),"\nList of CCs to disallow showing code for using this command."))),(0,a.kt)("h2",{id:"code"},"Code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gotmpl",metastring:"file=../../../src/utilities/cc2file.go.tmpl",file:"../../../src/utilities/cc2file.go.tmpl"},'{{/*\n    Sends your custom command code as a text file on Discord. Supports showing more than one CC at a time.\n    See <https://yagpdb-cc.github.io/utilities/cc2file> for more information.\n    \n    Author: MatiasMFM2001 <https://github.com/MatiasMFM2001>\n*/}}\n\n{{/* Configurable values */}}\n{{$limitTo5CCs:= true}}\n{{$CCInfo_MessageContent:= true}}\n{{$CCInfo_Attachment:= false}}\n{{$blacklisted_CCIDs:= cslice 1234 5678}}\n{{$hideBlacklistedCCs:= false}}\n{{/* End of configurable values */}}\n\n{{/*\n    sendLongMessage is able to split a long text and send them in individual messages (of 2000 chars long max)\n\n    INPUT (arguments) is an SDICT with keys:\n        [String/Int/nil] "channelID" = Channel ID/Name/nil where message(s) will be sent\n        [String] "text" = The content itself you want to send\n        [String] "separator" = This will define when a \'word\' starts or ends\n*/}}\n{{define "sendLongMessage"}}\n    {{$outStr:= ""}}\n\n    {{/*If separator is not found on the text, fallback to a default empty string*/}}\n    {{if not (in .text .separator)}}\n        {{.Set "separator" ""}}\n    {{end}}\n\n    {{/*Split text in \'words\' and iterate over them*/}}\n    {{range (split .text .separator)}}\n        {{/*Keep appending words while length is under the limit. Then, send the message and "reset" the content for a new message*/}}\n        {{- if gt (add (len $outStr) (len .)) 2000}}\n            {{- sendMessage $.channelID $outStr}}\n            {{- $outStr = .}}\n        {{- else}}\n            {{- $outStr = joinStr $.separator $outStr .}}\n        {{- end -}}\n    {{end}}\n\n    {{/*Send the last message, that was left when range loop ended*/}}\n    {{sendMessage .channelID $outStr}}\n{{end}}\n\n{{/*\n    parseCC executes "-cc .argument" and extracts all possible information from it\n\n    INPUT is an SDICT with keys:\n        [String] "argument" = The CC ID or Trigger to parse\n\n    OUTPUT is the same SDICT with keys:\n        [String] "error" = If there are errors, they will be returned here (as a string)\n        [Int] "CCID" = The ID of processed CC\n        [String] "triggerType" = The type of the trigger this CC has (i.e. "None", "Command", "Regex", etc)\n        [String] "trigger" = The trigger itself this CC has (i.e. "cc2file", ".*", etc)\n        [Bool] "caseSensitive" = If lowercase and uppercase characters, are not considered equal\n        [String] "group" = CC group, this CC belongs to\n        [String] "code" = Executable source code of this CC\n*/}}\n{{define "parseCC"}}\n    {{/*EXECute "-cc" and extract stuff from its output*/}}\n    {{$answer:= exec "cc" .argument}}\n    {{$answerLines:= split $answer "\\n"}}\n    {{$extractedCode:= slice $answerLines 2 (sub (len $answerLines) 1)}}\n    {{$firstLine:= index $answerLines 0}}\n\n    {{/*Check if Answer\'s $firstLine is actually an error message*/}}\n    {{- if in $firstLine "here is a list of"}}\n        {{.Set "error" (printf "\u274c CC `%s` not found" .argument)}}\n    {{- else if in $firstLine "More than 1 matched command"}}\n        {{/*Insert argument in message output, and if it\'s empty, replace it with "<Empty trigger specified>"*/}}\n        {{.Set "error" (reReplace "``" (printf "`%s`: %s" .argument $answer) "`<Empty trigger specified>`")}}\n    {{end}}\n\n    {{/*If not, extract info from the CC*/}}\n    {{if not .error}}\n        {{/*Modified copy of TheHDCrafter\'s Regex expression. Licensed under MIT*/}}\n        {{$parsedFirstLine:= reFindAllSubmatches `^#\\s*(\\d+) - ((.*)(?:(?:: \\x60(.*)\\x60 - Case sensitive trigger: \\x60(.+)\\x60)|\\b))? - Group: \\x60(.+)\\x60$` $firstLine}}\n\n        {{.Set "CCID" (index $parsedFirstLine 0 1 | toInt)}}\n        {{.Set "triggerType" (or (index $parsedFirstLine 0 3) "None")}}\n        {{.Set "trigger" (index $parsedFirstLine 0 4)}}\n        {{.Set "caseSensitive" (index $parsedFirstLine 0 5 | eq "true")}}\n        {{.Set "group" (index $parsedFirstLine 0 6)}}\n\n        {{.Set "code" (joinStr "\\n" $extractedCode)}}\n    {{end}}\n{{end}}\n\n{{/*EXECUTION STARTS HERE*/}}\n{{/*If CC was called via execCC/scheduleUniqueCC, use .ExecData as the $args. If not, use .CmdArgs*/}}\n{{$args:= cslice}}\n{{with .ExecData}}\n    {{$args = .}}\n{{else}}\n    {{/*Delete duplicated $args*/}}\n    {{range .CmdArgs}}\n        {{- if not (in $args .)}}\n            {{- $args = $args.Append .}}\n        {{- end}}\n    {{- end}}\n{{end}}\n{{$numArgs:= len $args}}\n\n{{/*Exec can be called 5 times max, so $selectedArgs will have up to 5 $args to be processed*/}}\n{{$selectedArgs:= cslice}}\n{{if gt $numArgs 5}}\n    {{$selectedArgs = slice $args 0 5}}\n\n    {{if $limitTo5CCs}}\n        {{sendMessage nil "\u26a0\ufe0f WARNING: Only first 5 CCs will be processed"}}\n    {{end}}\n{{else}}\n    {{$selectedArgs = $args}}\n{{end}}\n\n{{/*Process each selected argument in this execution*/}}\n{{range $selectedArgs}}\n    {{- $params:= sdict "argument" .}}\n    {{- template "parseCC" $params}}\n\n    {{/*Check if that CC was $blacklisted*/}}\n    {{- if $params.error}}\n        {{- sendMessage nil $params.error}}\n    {{- else if in $blacklisted_CCIDs $params.CCID}}\n        {{- sendMessage nil (printf "\ud83d\udeab CC `%s` is blacklisted" .)}}\n    {{- else}}\n        {{/*No error message, so send CC\'s code and info*/}}\n        {{- $content:= ""}}\n        {{- $attachment:= $params.code}}\n\n        {{/*If $CCInfo_MessageContent flag is set, the info will be sent as message content*/}}\n        {{- if $CCInfo_MessageContent}}\n            {{- $content = printf "#%d - %s: `%s` - Case sensitive trigger: `%t` - Group: `%s`" $params.CCID $params.triggerType $params.trigger $params.caseSensitive $params.group}}\n        {{- end}}\n\n        {{/*If $CCInfo_Attachment flag is set, the info will be a comment in message\'s attachment*/}}\n        {{- if $CCInfo_Attachment}}\n            {{/*Generate the $leadingComment*/}}\n            {{- $leadingComment:= printf "{{/*\\n\\tDescription:\\n\\n\\tUsage:\\n"}}\n\n            {{- range reFindAllSubmatches `parseArgs\\s+\\d+\\s+"(.+)"` $params.code}}\n                {{- $leadingComment = printf "%s\\t\\t\\"%s\\"\\n" $leadingComment (index . 1)}}\n            {{- end}}\n\n            {{- $leadingComment = printf "%s\\n\\tRecomended trigger: \\"%s\\"\\n\\tTrigger type: %s\\n\\n\\tCredits:\\n*/}}" $leadingComment $params.trigger $params.triggerType}}\n\n            {{- $attachment = printf "%s\\n\\n%s" $leadingComment $attachment}}\n        {{- end}}\n\n        {{- sendMessage nil (complexMessage\n            "content" $content\n            "file" $attachment\n        )}}\n    {{- end}}\n\n    {{- sleep 1}}\n{{else}}\n    {{/*If there are 0 args, send full CC list*/}}\n    {{$answerLines:= split (exec "cc") "\\n"}}\n\n    {{/*Save the first line, and the rest of them, in different variables*/}}\n    {{$newMessage:= index $answerLines 0}}\n    {{$answerLines:= slice $answerLines 1 (sub (len $answerLines) 1) | cslice.AppendSlice}}\n\n    {{/*For each CC, if It\'s blacklisted, strikethrough whole line*/}}\n    {{range $index, $content:= $answerLines}}\n        {{- $CCID:= index (reFindAllSubmatches `^\\x60#([0-9 ]{3})` $content) 0 1 | toInt}}\n\n        {{- if in $blacklisted_CCIDs $CCID}}\n            {{- if $hideBlacklistedCCs}}\n                {{- $answerLines.Set $index ""}}\n            {{- else}}\n                {{- $answerLines.Set $index (printf "~~%s~~" $content)}}\n            {{- end}}\n        {{- end}}\n    {{end}}\n\n    {{/*A DIY "joinStr `\\n` $answerLines"*/}}\n    {{range $answerLines}}\n        {{- $newMessage = printf "%s\\n%s" $newMessage .}}\n    {{end}}\n\n    {{template "sendLongMessage" (sdict "channelID" nil "text" $newMessage "separator" "\\n")}}\n{{end}}\n\n{{/*If $limitTo5CCs flag is not set, and there are still arguments left, execute CC again to process them*/}}\n{{if and (not $limitTo5CCs) (gt $numArgs 5)}}\n    {{scheduleUniqueCC .CCID nil 1 "cc2file - remaining args" (slice $args 5 $numArgs)}}\n{{end}}\n')),(0,a.kt)("h2",{id:"author"},"Author"),(0,a.kt)("p",null,"This custom command was written by ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/MatiasMFM2001"},"@MatiasMFM2001"),"."))}p.isMDXComponent=!0}}]);